
//#include <chrono>
#include <sys/time.h>
#include <stdexcept>
#include <time.h>
#include "SAL_SALData.h"
using namespace SALData;

SAL_SALData::SAL_SALData(int aKey)
{
   char *dname = getenv("LSST_DDS_DOMAIN");
   if ( dname != NULL ) {
      strncpy(domainName, dname, 128);
   } else {
      strncpy(domainName, "LSST", 128);
   }
   hasReader = false;
   hasWriter = false;
   hasCommand = false;
   hasProcessor = false;
   hasEventReader = false;
   hasEventWriter = false;
   subsystemID = aKey;
   debugLevel = 1;
   initSalActors();
}

SAL_SALData::SAL_SALData()
{
   char *dname = getenv("LSST_DDS_DOMAIN");
   if ( dname != NULL ) {
      strncpy(domainName, dname, 128);
   } else {
      strncpy(domainName, "LSST", 128);
   }
   hasReader = false;
   hasWriter = false;
   hasCommand = false;
   hasEventReader = false;
   hasEventWriter = false;
   hasProcessor = false;
   subsystemID = 0;
   debugLevel = 1;
   initSalActors();
}

/**
 * Returns the name of an error code.
 **/
string SAL_SALData::getErrorName(DDS::ReturnCode_t status)
{
  return RetCodeName[status];
}

/**
 * Check the return status for errors. If there is an error, then terminate.
 **/
void SAL_SALData::checkStatus(DDS::ReturnCode_t status, const char *info)
{


  if (status != DDS::RETCODE_OK && status != DDS::RETCODE_NO_DATA)
  {
    cerr << "Error in " << info << ": " << getErrorName(status).c_str() << endl;
    throw std::runtime_error(getErrorName(status).c_str());
  }
}

/**
 * Check whether a valid handle has been returned. If not, then terminate.
 **/
void SAL_SALData::checkHandle(void *handle, string info)
{

  if (!handle)
  {
    cerr << "Error in " << info.c_str() << ": Creation failed: invalid handle" << endl;
    throw std::runtime_error("Creation failed: invalid handle");
  }
}


double SAL_SALData::getCurrentTime()
{
     struct timeval now;
     struct timezone zone;
     double ts;

     gettimeofday(&now, &zone);
     ts = (double)now.tv_sec + (double)now.tv_usec/1000000.;
     return ts;
}

double SAL_SALData::getRcvdTime()
{
     return rcvdTime;
}

void SAL_SALData::setTuneableQos (char *topicName) {
    int actorIdx;
    actorIdx = getActorIndex(topicName);
    if (actorIdx > 0) {
       sal[actorIdx].tuneableQos = true;
    }
}


void SAL_SALData::setDefaultQos (char *topicName) {
    int actorIdx;
    actorIdx = getActorIndex(topicName);
    if (actorIdx > 0) {
       sal[actorIdx].tuneableQos = false;
    }
}


int SAL_SALData::getActorIndex (char *topicName)
{
  for (int i=0; i<SAL__ACTORS_MAXCOUNT;i++) {
     if ( strlen(topicName) == strlen(sal[i].topicName) )  {
       if ( strcmp(topicName,sal[i].topicName) == 0 )  {
          return i;
       }
     }
  }
  throw std::runtime_error("Unknown topic");
  return SAL__ERROR;
}

bool SAL_SALData::actorActive(int actorIdx) {
  if ( sal[actorIdx].isActive ) {
     return true;
  }
  return false;
}

bool SAL_SALData::actorReader(int actorIdx) {
  if ( sal[actorIdx].isReader ) {
     return true;
  }
  return false;
}

bool SAL_SALData::actorWriter(int actorIdx) {
  if ( sal[actorIdx].isWriter ) {
     return true;
  }
  return false;
}

bool SAL_SALData::actorCommand(int actorIdx) {
  if ( sal[actorIdx].isCommand ) {
     return true;
  }
  return false;
}

bool SAL_SALData::actorEventReader(int actorIdx) {
  if ( sal[actorIdx].isEventReader ) {
     return true;
  }
  return false;
}

bool SAL_SALData::actorEventWriter(int actorIdx) {
  if ( sal[actorIdx].isEventWriter ) {
     return true;
  }
  return false;
}

bool SAL_SALData::actorProcessor(int actorIdx) {
  if ( sal[actorIdx].isProcessor ) {
     return true;
  }
  return false;
}


int SAL_SALData::getIntProperty(int actorIdx,salCHAR *property)
{
  if (strcmp("ack", property) == 0) {return sal[actorIdx].ack;}
  if (strcmp("error", property) == 0) {return sal[actorIdx].error;}
  if (strcmp("rcvSeqNum", property) == 0) {return sal[actorIdx].rcvSeqNum;}
  return SAL__OK;
}




// INSERT TYPE SUPPORT      

salReturn SAL_SALData::salTelemetryPub(char *topicName)
{
  int actorIdx = -1;
  int status = 0;

  actorIdx = getActorIndex(topicName);
  if (actorIdx > -1) {
     status = salTelemetryPub(actorIdx);
  } else {
     status = SAL__ERROR;
     throw std::runtime_error("Unknown topic");
  }
  return status;
}

salReturn SAL_SALData::salTelemetrySub(char *topicName)
{
  int actorIdx = -1;
  int status = 0;

  actorIdx = getActorIndex(topicName);
  if (actorIdx > -1) {
     status = salTelemetrySub(actorIdx);
  } else {
     status = SAL__ERROR;
     throw std::runtime_error("Unknown topic");
  }
  return status;
}
 

salReturn SAL_SALData::salTelemetryPub(int actorIdx)
{
  // create domain participant
  createParticipant(domainName);

  //create type
  salTypeSupport(actorIdx);

  //create Topic
  createTopic(actorIdx);

  //create Publisher
  createPublisher(actorIdx);

  // create DataWriter :
  // If autodispose_unregistered_instances is set to true (default value),
  // you will have to start the subscriber before the publisher
  bool autodispose_unregistered_instances = false;
  createWriter(actorIdx,autodispose_unregistered_instances);
  DataWriter_var dwriter = getWriter(actorIdx);
  sal[actorIdx].isWriter = true;
  return SAL__OK;
}



       
salReturn SAL_SALData::salTelemetrySub(int actorIdx)
{
   // create domain participant
   createParticipant(domainName);

   //create type
   salTypeSupport(actorIdx);

   //create Topic
   createTopic(actorIdx);

   //create Subscriber
   createSubscriber(actorIdx);

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   // Filter expr
   char buf[64];
   sprintf(buf, "SALDataID = %d", subsystemID);
   DDS::String_var sFilter = DDS::string_dup(buf);
   // Filter expr
   StringSeq sSeqExpr;
   sSeqExpr.length(0);
   // create topic
   char ftopicName[128];
   sprintf(ftopicName,"%s_%d","filtered",actorIdx);
   createContentFilteredTopic(actorIdx,ftopicName, sFilter.in(), sSeqExpr);
   // create DataReader
   createReader(actorIdx,true);
#else
   createReader(actorIdx,false);
#endif
   sal[actorIdx].isReader = true;
   return SAL__OK;
}



void SAL_SALData::logError(salReturn status) 
{
   cout << "=== ERROR return value = " << status << endl; 
}

/*
using Clock = std::chrono::high_resolution_clock;
using Time_point = Clock::time_point;
using std::chrono::milliseconds;
using std::chrono::duration_cast;

salTIME SAL_SALData::currentTime()
{
    Time_point tp = Clock::now();   
    return (salTIME duration_cast<milliseconds>tp.count());
}
*/

int SAL_SALData::issueCommand( SALData::command data )
{

  InstanceHandle_t cmdHandle = DDS::HANDLE_NIL;
  time_t sTime;

  // create DataWriter :
  // If autodispose_unregistered_instances is set to true (default value),
  // you will have to start the subscriber before the publisher
  bool autodispose_unregistered_instances = false;
  if (!hasWriter) {
     createWriter(autodispose_unregistered_instances);
     hasWriter = true;
     sndSeqNum = time(&sTime);
  }
  DataWriter_var dwriter = getWriter();
  SALCommandDataWriter_var SALWriter = SALCommandDataWriter::_narrow(dwriter.in());
  data.private_revCode = DDS::string_dup("LSST TEST COMMAND");
  data.private_seqNum = sndSeqNum;
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
  data.SALDataID = subsystemID;
  cmdHandle = SALWriter->register_instance(data);
#endif
  if (debugLevel > 0) {
    cout << "=== [issueCommand] writing a command containing :" << endl;
    cout << " " << data.device << "." << data.property << "." << data.action << " : " << data.itemValue << endl;
  }
  data.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(data, cmdHandle);
  sndSeqNum++;
  checkStatus(status, "SALCommandDataWriter::write");  
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    SALWriter->unregister_instance(data, cmdHandle);
#endif
  if (status != SAL__OK) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
  }
  return (sndSeqNum-1);
}
      
int SAL_SALData::issueCommandC( SALData_commandC *data )
{

  InstanceHandle_t cmdHandle = DDS::HANDLE_NIL;
  time_t sTime;
  SALData::command Instance;

  // create DataWriter :
  // If autodispose_unregistered_instances is set to true (default value),
  // you will have to start the subscriber before the publisher
  bool autodispose_unregistered_instances = false;
  if (!hasWriter) {
     createWriter(autodispose_unregistered_instances);
     hasWriter = true;
     sndSeqNum = time(&sTime);
  }
  DataWriter_var dwriter = getWriter();
  SALCommandDataWriter_var SALWriter = SALCommandDataWriter::_narrow(dwriter.in());

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
  Instance.SALDataID = subsystemID;
  cmdHandle = SALWriter->register_instance(Instance);
#endif

  Instance.private_revCode =  DDS::string_dup("LSST TEST REVCODE");
  Instance.private_sndStamp = 1;
  Instance.private_origin =   1;
  Instance.private_seqNum =   sndSeqNum;
  Instance.private_host =     1;
  Instance.device =           DDS::string_dup(data->device.c_str());
  Instance.property =         DDS::string_dup(data->property.c_str());
  Instance.action =           DDS::string_dup(data->action.c_str());
  Instance.itemValue =        DDS::string_dup(data->itemValue.c_str());
  Instance.modifiers =        DDS::string_dup(data->modifiers.c_str());

  if (debugLevel > 0) {
    cout << "=== [issueCommandC] writing a command containing :" << endl;
    cout << " " << Instance.device << "." << Instance.property << "." << Instance.action << " : " << Instance.itemValue << endl;
  }  
  Instance.private_sndStamp = getCurrentTime();
  ReturnCode_t status = SALWriter->write(Instance, cmdHandle);
  sndSeqNum++;
  checkStatus(status, "SALCommandDataWriter::write");  
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    SALWriter->unregister_instance(Instance, cmdHandle);
#endif
  if (status != SAL__OK) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
  }
  return (sndSeqNum-1);
}



salReturn SAL_SALData::acceptCommand( SALData::commandSeq data )
{
   SampleInfoSeq info;
   ReturnCode_t status = 0;
   ReturnCode_t istatus =  -1;
   SALData::ackcmd ackdata;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;

  // create DataWriter :
  // If autodispose_unregistered_instances is set to true (default value),
  // you will have to start the subscriber before the publisher
  bool autodispose_unregistered_instances = false;
  if (!hasWriter) {
     createWriter2(autodispose_unregistered_instances);
     hasWriter = true;
  }
  DataWriter_var dwriter = getWriter2();
  SALData::ackcmdDataWriter_var SALWriter = SALData::ackcmdDataWriter::_narrow(dwriter.in());
  DataReader_var dreader = getReader();
  SALData::commandDataReader_var SALReader = SALData::commandDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "SALData::commandDataReader::_narrow");
  istatus = SALReader->take(data, info, 1,ANY_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(istatus, "SALData::commandDataReader::take");
  if (info.length() > 0) {
   if (info[0].valid_data) {
    if (debugLevel > 0) {
      cout << "=== [acceptCommand] reading a command containing :" << endl;
      cout << "    seqNum   : " << data[0].private_seqNum << endl;
      cout << "    device   : " << data[0].device << endl;
      cout << "    property : " << data[0].property << endl;
      cout << "    action   : " << data[0].action << endl;
      cout << "    itemValue: " << data[0].itemValue << endl;
      cout << "    modifiers: " << data[0].modifiers << endl;
    }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackdata.SALDataID = subsystemID;
#endif
    ackdata.private_origin = data[0].private_origin;
    ackdata.private_seqNum = data[0].private_seqNum;
    ackdata.error = 0;
    ackdata.result = DDS::string_dup("SAL ACK");
    status = data[0].private_seqNum;
    rcvSeqNum = status;
    rcvdTime = getCurrentTime();
    rcvOrigin = data[0].private_origin;
    ackdata.ack = SAL__CMD_ACK;
    istatus = SALReader->return_loan(data, info);
    checkStatus(istatus, "SALData::commandDataReader::return_loan");
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackHandle = SALWriter->register_instance(ackdata);
    ackdata.SALDataID = subsystemID;
#endif
    ackdata.private_sndStamp = getCurrentTime();
    istatus = SALWriter->write(ackdata, ackHandle);
    checkStatus(istatus, "SALData::ackcmdDataWriter::return_loan");
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    SALWriter->unregister_instance(ackdata, ackHandle);
#endif
   }
  } else {
    status = 0;
  }
  return status;
}



int SAL_SALData::acceptCommandC( SALData_commandC *data )
{
   SampleInfoSeq info;
   ReturnCode_t status = 0;
   ReturnCode_t istatus =  -1;
   SALData::commandSeq cmd;
   SALData::ackcmd ackdata;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;

  // create DataWriter :
  // If autodispose_unregistered_instances is set to true (default value),
  // you will have to start the subscriber before the publisher
  bool autodispose_unregistered_instances = false;
  if (!hasWriter) {
     createWriter2(autodispose_unregistered_instances);
     hasWriter = true;
  }
  DataWriter_var dwriter = getWriter2();
  SALData::ackcmdDataWriter_var SALWriter = SALData::ackcmdDataWriter::_narrow(dwriter.in());
  DataReader_var dreader = getReader();
  SALData::commandDataReader_var SALReader = SALData::commandDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "SALData::commandDataReader::_narrow");
  istatus = SALReader->take(cmd, info, 1,ANY_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(istatus, "SALData::commandDataReader::take");
  if (info.length() > 0) {
   if (info[0].valid_data) {
    if (debugLevel > 0) {
      cout << "=== [acceptCommandC] reading a command containing :" << endl;
      cout << "    seqNum   : " << cmd[0].private_seqNum << endl;
      cout << "    device   : " << cmd[0].device << endl;
      cout << "    property : " << cmd[0].property << endl;
      cout << "    action   : " << cmd[0].action << endl;
      cout << "    itemValue: " << cmd[0].itemValue << endl;
      cout << "    modifiers: " << cmd[0].modifiers << endl;
    }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackdata.SALDataID = subsystemID;
#endif
    ackdata.private_origin = cmd[0].private_origin;
    ackdata.private_seqNum = cmd[0].private_seqNum;
    ackdata.error = 0;
    ackdata.result = DDS::string_dup("SAL ACK");
    status = cmd[0].private_seqNum;
    rcvdTime = getCurrentTime();
    rcvSeqNum = status;
    rcvOrigin = cmd[0].private_origin;
    ackdata.ack = SAL__CMD_ACK;

    data->device = cmd[0].device;
    data->property = cmd[0].property;
    data->action = cmd[0].action;
    data->itemValue = cmd[0].itemValue;
    data->modifiers = cmd[0].modifiers;

    istatus = SALReader->return_loan(cmd, info);
    checkStatus(istatus, "SALData::commandDataReader::return_loan");
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    ackHandle = SALWriter->register_instance(ackdata);
    ackdata.SALDataID = subsystemID;
#endif
    ackdata.private_sndStamp = getCurrentTime();
    istatus = SALWriter->write(ackdata, ackHandle);
    checkStatus(istatus, "SALData::ackcmdDataWriter::write");
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    SALWriter->unregister_instance(ackdata, ackHandle);
#endif
   }
  } else {
    status = 0;
  }
  return status;
}


// INSERT CMDALIAS SUPPORT  for issueCommandC and acceptCommandC, acceptAnyCommand   



salReturn SAL_SALData::ackCommand( int cmdId, salLONG ack, salLONG error, char *result )
{
   ReturnCode_t istatus = -1;
   InstanceHandle_t ackHandle = DDS::HANDLE_NIL;

   SALData::ackcmd ackdata;
   DataWriter_var dwriter = getWriter2();
   SALData::ackcmdDataWriter_var SALWriter = SALData::ackcmdDataWriter::_narrow(dwriter.in());

   ackdata.private_origin = rcvOrigin;
   ackdata.private_seqNum = rcvSeqNum;
   ackdata.error = error;
   ackdata.ack = ack;
   ackdata.result = DDS::string_dup(result);
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackdata.SALDataID = subsystemID;
#endif
   if (debugLevel > 0) {
      cout << "=== [ackCommand] acknowledging a command with :" << endl;
      cout << "    seqNum   : " << ackdata.private_seqNum << endl;
      cout << "    ack      : " << ackdata.ack << endl;
      cout << "    error    : " << ackdata.error << endl;
      cout << "    result   : " << ackdata.result << endl;
   }
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   ackHandle = SALWriter->register_instance(ackdata);
   ackdata.SALDataID = subsystemID;
#endif
   ackdata.private_sndStamp = getCurrentTime();
   istatus = SALWriter->write(ackdata, ackHandle);
   checkStatus(istatus, "SALData::ackcmdDataWriter::return_loan");
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    SALWriter->unregister_instance(ackdata, ackHandle);
#endif
   return SAL__OK;
}


salReturn SAL_SALData::checkCommand( int cmdSeqNum )
{
   salReturn status = SAL__OK;
   SALData::ackcmdSeq response;
   status = getResponse(response);
   if (status != SAL__OK) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
   }
   return status;
}

salReturn SAL_SALData::getResponse(SALData::ackcmdSeq data)
{
  SampleInfoSeq info;
  ReturnCode_t status =  - 1;
  ReturnCode_t istatus =  - 1;
  DataReader_var dreader = getReader2();
  SALData::ackcmdDataReader_var SALReader = SALData::ackcmdDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "SALData::ackcmdDataReader::_narrow");
  istatus = SALReader->take(data, info, 1,ANY_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  rcvSeqNum = 0;
  rcvOrigin = 0;
  checkStatus(istatus, "SALData::ackcmdDataReader::take");
  if (info.length() > 0) {
    if (debugLevel > 0) {
      cout << "=== [getResponse] reading a message containing :" << endl;
      cout << "    revCode  : " << data[0].private_seqNum << endl;
      cout << "    error    : " << data[0].error << endl;
      cout << "    ack      : " << data[0].ack << endl;
      cout << "    result   : " << data[0].result << endl;
    }
    status = data[0].ack;
    rcvdTime = getCurrentTime();
    rcvSeqNum = data[0].private_seqNum;
    rcvOrigin = data[0].private_origin;
    istatus = SALReader->return_loan(data, info);
    checkStatus(istatus, "SALData::ackcmdDataReader::return_loan");
  } else {
      cout << "=== [getResponse] No ack yet!" << endl;
      status = SAL__CMD_NOACK;
  }
  return status;
}


salReturn SAL_SALData::cancelCommand( int cmdSeqNum )
{
   salReturn status = SAL__OK;
   if (status != SAL__OK) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
   }
   return status;
}

salReturn SAL_SALData::abortCommand( int cmdSeqNum )
{
   salReturn status = SAL__OK;
   if (status != SAL__OK) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
   }
   return status;
}

salReturn SAL_SALData::waitForCompletion( int cmdSeqNum , unsigned int timeout )
{
   salReturn status = SAL__OK;
   int countdown = timeout;
   SALData::ackcmdSeq response;

   while (status != SAL__CMD_COMPLETE && countdown != 0) {
      status = getResponse(response);
      if (status != SAL__CMD_NOACK) {
        if (rcvSeqNum != cmdSeqNum) { 
           status = SAL__CMD_NOACK;
        }
      }
      usleep(SAL__SLOWPOLL);
      countdown--;
   }
   if (status != SAL__CMD_COMPLETE) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion] command " << cmdSeqNum <<  " timed out :" << endl;
      } 
   } else {
      if (debugLevel > 0) {
         cout << "=== [waitForCompletion] command " << cmdSeqNum << " completed ok :" << endl;
      } 
   }

   return status;
}

salReturn SAL_SALData::setDebugLevel( int level )
{
   debugLevel = level;
   salReturn status = SAL__OK;
   if (status != SAL__OK) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
   }
   return status;
}

int SAL_SALData::getDebugLevel( int level )
{
   return debugLevel;
}

int SAL_SALData::getOrigin()
{
   salReturn status = SAL__OK;
   if (status != SAL__OK) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
   }
   return status;
}
      
void SAL_SALData::setMaxSamples(int actorIdx, int n)
{
    if ( n < 0 ) {
       sal[actorIdx].maxSamples = LENGTH_UNLIMITED;
    } else {
       sal[actorIdx].maxSamples = n;
    }
}



int SAL_SALData::getProperty(salCHAR *property, salCHAR *value)
{
   salReturn status = SAL__OK;
   strcpy(value,"UNKNOWN");
   if (status != SAL__OK) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
   }
   return status;
}

salReturn SAL_SALData::setProperty(salCHAR *property, salCHAR *value)
{
   if (status != SAL__OK) {
      if (debugLevel >= SAL__LOG_ROUTINES) {
          logError(status);
      }
   }
   return status;
}
 
/* 
template <class T1, class T2>
void SAL_SALData::putSample(T1 data, T2 SALWriter)
{
  T1 SALInstance = data;
  SALInstance.private_revCode = DDS::string_dup("LSST TEST REVCODE");
  cout << "=== [putSample] writing a message containing :" << endl;
  cout << "    revCode  : " << SALInstance.private_revCode << endl;

  ReturnCode_t status = SALWriter->write(SALInstance, DDS::HANDLE_NIL);
  checkStatus(status, "SALTopicDataWriter::write");  
}

template <class T1, class T2, class T3>
void SAL_SALData::getSample(T1 data, T2 info, T3 SALReader)
{
  ReturnCode_t status =  - 1;
  status = SALReader->take(data, info, LENGTH_UNLIMITED,ANY_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "SALTopicDataReader::take");
  cout << "=== [getSample] reading a message containing :" << endl;
  cout << "    revCode  : " << data.private_revCode << endl;
  status = SALReader->return_loan(data, info);
  checkStatus(status, "SALTopicDataReader::return_loan");
}


void SAL_SALData::getSharedMem([set base]_[set name]_cache * pshm_[set base]_[set name]) {
       pshm_[set base]_[set name] = ([set base]_[set name]_cache *) m_shared_mem;
}


//#include "shmem_[set base]_[set name].h"
int SAL_SALData::attachSharedMem([set base]_[set name]_cache * pshm_[set base]_[set name])
{       
       shm_[set base]_[set name] *obj = new shm_[set base]_[set name]();
       obj->GetObject(pshm_[set base]_[set name]);
       if (debugLevel > 0) {
         cout << (size_t)pshm_[set base]_[set name] << "	";
         cout << "sync0 = " << obj->syncO << endl;
       }  
       obj->Handle();
       return 0;
}

int SAL_SALData::sharedMemPublish([set base]_[set name]_cache *shmdata_ref,[set base]_[set name]C *data ) 
{
	attatchSharedMem(shmdata_ref, data);
#loop waiting for syncO then publish
	data->X = shmdata_ref->X;      
}

int SAL_SALData::sharedMemSubscribe([set base]_[set name]_cache *shmdata_ref,[set base]_[set name]C *data ) 
{
	attatchSharedMem(shmdata_ref, data);
#launch reader callback, which writes to shm and sets syncI
#seperate getShmSample routine reads shm data
	data->X = shmdata_ref->X;      
}
*/

salReturn SAL_SALData::getEvent(SALData::logeventSeq data)
{
  SampleInfoSeq info;
  ReturnCode_t status =  - 1;
  string stopic="SALData_logevent";

  if (hasEventReader == false) {
     salTelemetrySub(const_cast<char*>(stopic.c_str()));
     hasEventReader = true;
  }
  DataReader_var dreader = getReader();
  SALData::logeventDataReader_var SALReader = SALData::logeventDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "SALData::logeventDataReader::_narrow");
  status = SALReader->take(data, info,  1,ANY_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "SALData::logeventDataReader::take");
  if (info.length() > 0) {
   if (info[0].valid_data) {
     if (debugLevel > 0) {
       cout << "=== [getEvent] reading a message containing :" << endl;
       cout << "    revCode  : " << data[0].private_revCode << endl;
     }
     rcvdTime = getCurrentTime();
     status = SALReader->return_loan(data, info);
     checkStatus(status, "SALData::logeventDataReader::return_loan");
     status = SAL__OK;
   }
  } else {
   status = SAL__NO_UPDATES;
  }
  return status;
}

int SAL_SALData::getEventC(SALData_logeventC *cdata)
{
  SampleInfoSeq info;
  ReturnCode_t status =  -1;
  int actorIdx = SAL__SALData_logevent_ACTOR;
  string stopic="SALData_logevent";

  if (sal[actorIdx].isEventReader == false) {
     salTelemetrySub(const_cast<char*>(stopic.c_str()));
     sal[actorIdx].isEventReader = true;
  }
  SALData::logeventSeq data;
  DataReader_var dreader = getReader(actorIdx);
  SALData::logeventDataReader_var SALReader = SALData::logeventDataReader::_narrow(dreader.in());
  checkHandle(SALReader.in(), "SALData::logeventDataReader::_narrow");
  status = SALReader->take(data, info,  1,ANY_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE);
  checkStatus(status, "SALData::logeventDataReader::take");
  if (info.length() > 0) {
   if (info[0].valid_data) {
     if (debugLevel > 0) {
       cout << "=== [getEvent] reading a message containing :" << endl;
       cout << "    revCode  : " << data[0].private_revCode << endl;
     }
     SALData::logevent *SALInstance = &(data[0]);
     rcvdTime = getCurrentTime();
     cdata->message=SALInstance->message.m_ptr;
     status = SALReader->return_loan(data, info);
     checkStatus(status, "SALData::logeventDataReader::return_loan");
     status = SAL__OK;
   } else {
     status = SAL__NO_UPDATES;
   }
  } else {
     status = SAL__NO_UPDATES;
  }
  return status;
}

salReturn SAL_SALData::logEvent( char *message, int priority )
{
   ReturnCode_t status = 0;
   ReturnCode_t istatus =  -1;
   int actorIdx = SAL__SALData_logevent_ACTOR;;
   SALData::logevent event;
   string stopic="SALData_logevent";
   InstanceHandle_t eventHandle = DDS::HANDLE_NIL;

  if (sal[actorIdx].isEventWriter == false) {
    salTelemetryPub(const_cast<char*>(stopic.c_str()));
    sal[actorIdx].isEventWriter = true;
  }
  DataWriter_var dwriter = getWriter(actorIdx);
  SALData::logeventDataWriter_var SALWriter = SALData::logeventDataWriter::_narrow(dwriter.in());
  event.message = DDS::string_dup(message);
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   event.SALDataID = subsystemID;
   eventHandle = SALWriter->register_instance(event);
#endif
  event.private_sndStamp = getCurrentTime();
  istatus = SALWriter->write(event, eventHandle);
  checkStatus(istatus, "SALData::logeventDataWriter::write");
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
    SALWriter->unregister_instance(event, eventHandle);
#endif
  return status;
}

// INSERT EVENTALIAS SUPPORT

salReturn SAL_SALData::salCommand()
{
  string stopic1="keyedCommand";
  string stopic2="keyedResponse";
  string command="SALData_command";
  string response="SALData_ackcmd";

  // create domain participant
  createParticipant(domainName);

  //create Publisher
  createPublisher();
  createSubscriber();

  //create types
  SALCommandTypeSupport_var mt = new SALCommandTypeSupport();
  registerType(mt.in());
  SALResponseTypeSupport_var mtr = new SALResponseTypeSupport();
  registerType2(mtr.in());

  //create Topics
  createTopic(const_cast<char*>(command.c_str()));
  createTopic2(const_cast<char*>(response.c_str()));

  //create a reader for responses
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
  // Filter expr
   char buf[64];
   sprintf(buf, "SALDataID = %d", subsystemID);
   DDS::String_var sFilter = DDS::string_dup(buf);
   // Filter expr
   StringSeq sSeqExpr;
   sSeqExpr.length(0);
  // create topic
  createContentFilteredTopic2("filteredResponse", sFilter.in(), sSeqExpr);
 // create DataReader
  createReader2(true);
#else
  createReader2(false);
#endif
  hasReader = true;
  hasCommand = true;
  return SAL__OK;
}


salReturn SAL_SALData::salCommand(char *cmdAlias)
{
  time_t sTime;
  int actorIdx = getActorIndex(cmdAlias);
  if (actorIdx < 0) {return SAL__ERROR;}
  string stopic1="keyedCommand";
  string stopic2="keyedResponse";
  string response="SALData_ackcmd";

  // create domain participant
  createParticipant(domainName);

  //create Publisher
  createPublisher(actorIdx);
  salTypeSupport(actorIdx);
  createSubscriber(SAL__SALData_ackcmd_ACTOR);
  createTopic(actorIdx,cmdAlias);

  if (sal[SAL__SALData_ackcmd_ACTOR].isReader == false) {
     //create types
     SALResponseTypeSupport_var mtr = new SALResponseTypeSupport();
     registerType2(SAL__SALData_ackcmd_ACTOR,mtr.in());

     //create Topics
     createTopic2(SAL__SALData_ackcmd_ACTOR,const_cast<char*>(response.c_str()));

     //create a reader for responses
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
     // Filter expr
     char buf[64];
     sprintf(buf, "SALDataID = %d", subsystemID);
     DDS::String_var sFilter = DDS::string_dup(buf);
     // Filter expr
     StringSeq sSeqExpr;
     sSeqExpr.length(0);
     // create topic
    createContentFilteredTopic2(SAL__SALData_ackcmd_ACTOR,"filteredResponse", sFilter.in(), sSeqExpr);
    // create DataReader
    createReader2(SAL__SALData_ackcmd_ACTOR,true);
#else
    createReader2(SAL__SALData_ackcmd_ACTOR,false);
#endif
    sal[SAL__SALData_ackcmd_ACTOR].sampleAge = 1.0;
    sal[SAL__SALData_ackcmd_ACTOR].isReader = true;
  }

  createWriter(actorIdx,true);
  sal[actorIdx].isCommand = true;
  sal[actorIdx].isWriter = true;
  sal[actorIdx].sndSeqNum = time(&sTime);
  return SAL__OK;
}

salReturn SAL_SALData::salProcessor()
{
  string stopic1="keyedCommand";
  string stopic2="keyedResponse";
  string command="SALData_command";
  string response="SALData_ackcmd";

  // create domain participant
  createParticipant(domainName);

  //create Publisher
  createPublisher();
  createSubscriber();

  //create types
  SALCommandTypeSupport_var mt = new SALCommandTypeSupport();
  registerType(mt.in());
  SALResponseTypeSupport_var mtr = new SALResponseTypeSupport();
  registerType2(mtr.in());

  //create Topics
  createTopic(const_cast<char*>(command.c_str()));
  createTopic2(const_cast<char*>(response.c_str()));

  //create a reader for commands
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
  // Filter expr
   char buf[64];
   sprintf(buf, "SALDataID = %d", subsystemID);
   DDS::String_var sFilter = DDS::string_dup(buf);
   // Filter expr
  StringSeq sSeqExpr;
  sSeqExpr.length(0);
  // create topic
  createContentFilteredTopic("filteredCommand", sFilter.in(), sSeqExpr);
 // create DataReader
  createReader(true);
#else
  createReader(false);
#endif
  bool autodispose_unregistered_instances = true;
  createWriter2(autodispose_unregistered_instances);
  hasWriter = true;
  hasProcessor = true;
  return SAL__OK;
}


salReturn SAL_SALData::salProcessor(char *cmdAlias)
{
  int actorIdx = getActorIndex(cmdAlias);
  if (actorIdx < 0) {return SAL__ERROR;}
  string stopic1="keyedCommand";
  string stopic2="keyedResponse";
  string response="SALData_ackcmd";

  // create domain participant
  createParticipant(domainName);

  createSubscriber(actorIdx);

  //create types
  salTypeSupport(actorIdx);
  createTopic(actorIdx,cmdAlias);


  //create Topics

  //create a reader for commands
#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
  // Filter expr
   char buf[64],buf2[64];
   sprintf(buf, "SALDataID = %d", subsystemID);
   DDS::String_var sFilter = DDS::string_dup(buf);
   // Filter expr
  StringSeq sSeqExpr;
  sSeqExpr.length(0);
  // create topic
   sprintf(buf2, "filteredCommand_%d", actorIdx);
  createContentFilteredTopic(actorIdx,buf2, sFilter.in(), sSeqExpr);
 // create DataReader
  createReader(actorIdx,true);
#else
  createReader(actorIdx,false);
#endif
  sal[actorIdx].isProcessor = true;
  sal[actorIdx].isReader = true;
  sal[actorIdx].sampleAge = 1.0;


  if ( sal[SAL__SALData_ackcmd_ACTOR].isWriter == false) {
    //create Publisher
    createPublisher(SAL__SALData_ackcmd_ACTOR);
    SALResponseTypeSupport_var mtr = new SALResponseTypeSupport();
    registerType2(SAL__SALData_ackcmd_ACTOR,mtr.in());
    createTopic2(SAL__SALData_ackcmd_ACTOR,const_cast<char*>(response.c_str()));
    bool autodispose_unregistered_instances = true;
    createWriter2(SAL__SALData_ackcmd_ACTOR,autodispose_unregistered_instances);
    sal[SAL__SALData_ackcmd_ACTOR].isWriter = true;
  }

  return SAL__OK;
}



salReturn SAL_SALData::salEvent(char *topicName)
{
  int actorIdx = getActorIndex(topicName);

  if ( actorIdx < 0) {return SAL__ERROR;}

  // create domain participant
  createParticipant(domainName);

  //create type
  salTypeSupport(actorIdx);

  //create Topic
  createTopic(actorIdx);
  createSubscriber(actorIdx);

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   // Filter expr
   char buf[64];
   sprintf(buf, "SALDataID = %d", subsystemID);
   DDS::String_var sFilter = DDS::string_dup(buf);
   // Filter expr
   StringSeq sSeqExpr;
   sSeqExpr.length(0);
   // create topic
   char ftopicName[128];
   sprintf(ftopicName,"%s_%s","filtered",sal[actorIdx].topicName);
   createContentFilteredTopic(actorIdx,ftopicName, sFilter.in(), sSeqExpr);
   // create DataReader
   createReader(actorIdx,true);
#else
   createReader(actorIdx,false);
#endif
   sal[actorIdx].isEventReader = true;
   return SAL__OK;
}

salReturn SAL_SALData::salEventPub(char *topicName)
{
  int actorIdx = getActorIndex(topicName);

  if ( actorIdx < 0) {return SAL__ERROR;}
  salTelemetryPub(actorIdx);
  sal[actorIdx].isEventWriter = true;
  return SAL__OK;
}


salReturn SAL_SALData::salEventSub(char *topicName)
{
  int actorIdx = getActorIndex(topicName);

  if ( actorIdx < 0) {return SAL__ERROR;}

  // create domain participant
  createParticipant(domainName);

  //create type
  salTypeSupport(actorIdx);

  //create Topic
  createTopic(actorIdx);
  createSubscriber(actorIdx);

#ifdef SAL_SUBSYSTEM_ID_IS_KEYED
   // Filter expr
   char buf[64];
   sprintf(buf, "SALDataID = %d", subsystemID);
   DDS::String_var sFilter = DDS::string_dup(buf);
   // Filter expr
   StringSeq sSeqExpr;
   sSeqExpr.length(0);
   // create topic
   char ftopicName[128];
   sprintf(ftopicName,"%s_%d","filtered",actorIdx);
   createContentFilteredTopic(actorIdx,ftopicName, sFilter.in(), sSeqExpr);
   // create DataReader
   createReader(actorIdx,true);
#else
   createReader(actorIdx,false);
#endif
   sal[actorIdx].isEventReader = true;
   return SAL__OK;
}


void SAL_SALData::salShutdown()
{
  if (participant != NULL) {
    participant->delete_contained_entities();
    deleteParticipant();
    participant = NULL;
  }
}

void SAL_SALData::createParticipant(const char *partitiontName)
{
  
  if (participant == NULL) {
    domain = DOMAIN_ID_DEFAULT;
    dpf = DomainParticipantFactory::get_instance();
    checkHandle(dpf.in(), "DDS::DomainParticipantFactory::get_instance");
    participant = dpf->create_participant(domain, PARTICIPANT_QOS_DEFAULT, NULL,STATUS_MASK_NONE);
    checkHandle(participant.in(),"DDS::DomainParticipantFactory::create_participant");
    partition = partitiontName;
  }
}

void SAL_SALData::deleteParticipant()
{
   status = dpf->delete_participant(participant.in());
   checkStatus(status, "DDS::DomainParticipant::delete_participant ");
}

void SAL_SALData::registerType(TypeSupport *ts)
{
  typeName = ts->get_type_name();
  status = ts->register_type(participant.in(), typeName);
  checkStatus(status, "register_type");
}

void SAL_SALData::registerType2(TypeSupport *ts)
{
  typeName2 = ts->get_type_name();
  status = ts->register_type(participant.in(), typeName2);
  checkStatus(status, "register_type");
}

void SAL_SALData::registerType(int actorIdx,TypeSupport *ts)
{
  sal[actorIdx].typeName = ts->get_type_name();
  status = ts->register_type(participant.in(), sal[actorIdx].typeName);
  checkStatus(status, "register_type");
}

void SAL_SALData::registerType2(int actorIdx,TypeSupport *ts)
{
  sal[actorIdx].typeName2 = ts->get_type_name();
  status = ts->register_type(participant.in(), sal[actorIdx].typeName2);
  checkStatus(status, "register_type");
}


void SAL_SALData::createTopic(char *topicName)
{
  status = participant->get_default_topic_qos(reliable_topic_qos);
  checkStatus(status, "DDS::DomainParticipant::get_default_topic_qos");
  reliable_topic_qos.reliability.kind = RELIABLE_RELIABILITY_QOS;
  reliable_topic_qos.durability.kind = TRANSIENT_DURABILITY_QOS;
  reliable_topic_qos.history.kind = KEEP_LAST_HISTORY_QOS;
  reliable_topic_qos.history.depth = 10000;

  /* Make the tailored QoS the new default. */
  status = participant->set_default_topic_qos(reliable_topic_qos);
  checkStatus(status, "DDS::DomainParticipant::set_default_topic_qos");

  topic = participant->create_topic(topicName, typeName, reliable_topic_qos,
    NULL, STATUS_MASK_NONE);
  checkHandle(topic.in(), "DDS::DomainParticipant::create_topic ()");
}

void SAL_SALData::createTopic2(char *topicName)
{
  status = participant->get_default_topic_qos(reliable_topic_qos2);
  checkStatus(status, "DDS::DomainParticipant::get_default_topic_qos");
  reliable_topic_qos2.reliability.kind = RELIABLE_RELIABILITY_QOS;
  reliable_topic_qos2.durability.kind = TRANSIENT_DURABILITY_QOS;
  reliable_topic_qos2.history.kind = KEEP_LAST_HISTORY_QOS;
  reliable_topic_qos2.history.depth = 10000;

  /* Make the tailored QoS the new default. */
  status = participant->set_default_topic_qos(reliable_topic_qos2);
  checkStatus(status, "DDS::DomainParticipant::set_default_topic_qos");

  topic2 = participant->create_topic(topicName, typeName2, reliable_topic_qos2,
    NULL, STATUS_MASK_NONE);
  checkHandle(topic2.in(), "DDS::DomainParticipant::create_topic ()");
}

void SAL_SALData::createTopic(int actorIdx)
{
  status = participant->get_default_topic_qos(sal[actorIdx].reliable_topic_qos);
  checkStatus(status, "DDS::DomainParticipant::get_default_topic_qos");
  if ( sal[actorIdx].tuneableQos) {
    sal[actorIdx].reliable_topic_qos.reliability.kind = RELIABLE_RELIABILITY_QOS;
    sal[actorIdx].reliable_topic_qos.durability.kind = TRANSIENT_DURABILITY_QOS;
    sal[actorIdx].reliable_topic_qos.history.kind = KEEP_LAST_HISTORY_QOS;
    sal[actorIdx].reliable_topic_qos.history.depth = sal[actorIdx].historyDepth;

  /* Make the tailored QoS the new default. */
    status = participant->set_default_topic_qos(sal[actorIdx].reliable_topic_qos);
    checkStatus(status, "DDS::DomainParticipant::set_default_topic_qos");
  }

  sal[actorIdx].topic = participant->create_topic(sal[actorIdx].topicName, sal[actorIdx].typeName, sal[actorIdx].reliable_topic_qos,
    NULL, STATUS_MASK_NONE);
  checkHandle(sal[actorIdx].topic.in(), "DDS::DomainParticipant::create_topic ()");
}

void SAL_SALData::createTopic2(int actorIdx)
{
  status = participant->get_default_topic_qos(sal[actorIdx].reliable_topic_qos2);
  checkStatus(status, "DDS::DomainParticipant::get_default_topic_qos");
  if ( sal[actorIdx].tuneableQos) {
    sal[actorIdx].reliable_topic_qos2.reliability.kind = RELIABLE_RELIABILITY_QOS;
    sal[actorIdx].reliable_topic_qos2.durability.kind = TRANSIENT_DURABILITY_QOS;
    sal[actorIdx].reliable_topic_qos2.history.kind = KEEP_LAST_HISTORY_QOS;
    sal[actorIdx].reliable_topic_qos2.history.depth = sal[actorIdx].historyDepth;

  /* Make the tailored QoS the new default. */
    status = participant->set_default_topic_qos(sal[actorIdx].reliable_topic_qos2);
    checkStatus(status, "DDS::DomainParticipant::set_default_topic_qos");
  }

  sal[actorIdx].topic2 = participant->create_topic(sal[actorIdx].topicName, sal[actorIdx].typeName2, sal[actorIdx].reliable_topic_qos2,
    NULL, STATUS_MASK_NONE);
  checkHandle(sal[actorIdx].topic2.in(), "DDS::DomainParticipant::create_topic ()");
}

void SAL_SALData::createTopic(int actorIdx, char *topicName)
{
  status = participant->get_default_topic_qos(sal[actorIdx].reliable_topic_qos);
  checkStatus(status, "DDS::DomainParticipant::get_default_topic_qos");
  if ( sal[actorIdx].tuneableQos) {
    sal[actorIdx].reliable_topic_qos.reliability.kind = RELIABLE_RELIABILITY_QOS;
    sal[actorIdx].reliable_topic_qos.durability.kind = TRANSIENT_DURABILITY_QOS;
    sal[actorIdx].reliable_topic_qos.history.kind = KEEP_LAST_HISTORY_QOS;
    sal[actorIdx].reliable_topic_qos.history.depth = sal[actorIdx].historyDepth;

  /* Make the tailored QoS the new default. */
    status = participant->set_default_topic_qos(sal[actorIdx].reliable_topic_qos);
    checkStatus(status, "DDS::DomainParticipant::set_default_topic_qos");
  }
  sal[actorIdx].topic = participant->create_topic(topicName, sal[actorIdx].typeName, sal[actorIdx].reliable_topic_qos,
    NULL, STATUS_MASK_NONE);
  checkHandle(sal[actorIdx].topic.in(), "DDS::DomainParticipant::create_topic ()");
}

void SAL_SALData::createTopic2(int actorIdx, char *topicName)
{
  status = participant->get_default_topic_qos(sal[actorIdx].reliable_topic_qos2);
  checkStatus(status, "DDS::DomainParticipant::get_default_topic_qos");
  if ( sal[actorIdx].tuneableQos) {
    sal[actorIdx].reliable_topic_qos2.reliability.kind = RELIABLE_RELIABILITY_QOS;
    sal[actorIdx].reliable_topic_qos2.durability.kind = TRANSIENT_DURABILITY_QOS;
    sal[actorIdx].reliable_topic_qos2.history.kind = KEEP_LAST_HISTORY_QOS;
    sal[actorIdx].reliable_topic_qos2.history.depth = sal[actorIdx].historyDepth;

  /* Make the tailored QoS the new default. */
    status = participant->set_default_topic_qos(sal[actorIdx].reliable_topic_qos2);
    checkStatus(status, "DDS::DomainParticipant::set_default_topic_qos");
  }
  sal[actorIdx].topic2 = participant->create_topic(topicName, sal[actorIdx].typeName2, sal[actorIdx].reliable_topic_qos2,
    NULL, STATUS_MASK_NONE);
  checkHandle(sal[actorIdx].topic2.in(), "DDS::DomainParticipant::create_topic ()");
}


void SAL_SALData::createContentFilteredTopic(const char *topicName, const
  char *filter, const StringSeq &expr)
{
  filteredtopic = participant->create_contentfilteredtopic(topicName, topic,
    filter, expr);
  checkHandle(filteredtopic.in(),
    "DomainParticipant::create_contentfilteredtopic");
}

void SAL_SALData::createContentFilteredTopic2(const char *topicName, const
  char *filter, const StringSeq &expr)
{
  filteredtopic2 = participant->create_contentfilteredtopic(topicName, topic2,
    filter, expr);
  checkHandle(filteredtopic2.in(),
    "DomainParticipant::create_contentfilteredtopic");
}

void SAL_SALData::createContentFilteredTopic(int actorIdx,const char *topicName, const char *filter, const StringSeq &expr)
{
  sal[actorIdx].filteredtopic = participant->create_contentfilteredtopic(topicName, sal[actorIdx].topic,
    filter, expr);
  checkHandle(sal[actorIdx].filteredtopic.in(),
    "DomainParticipant::create_contentfilteredtopic");
}

void SAL_SALData::createContentFilteredTopic2(int actorIdx,const char *topicName, const char *filter, const StringSeq &expr)
{
  sal[actorIdx].filteredtopic2 = participant->create_contentfilteredtopic(topicName, sal[actorIdx].topic2,
    filter, expr);
  checkHandle(sal[actorIdx].filteredtopic2.in(),
    "DomainParticipant::create_contentfilteredtopic");
}


void SAL_SALData::deleteTopics()
{
  if ( filteredtopic != NULL) {
    status = participant->delete_contentfilteredtopic(filteredtopic);
    checkStatus(status, "DDS.DomainParticipant.delete_topic");
  }
  if ( filteredtopic2 != NULL) {
    status = participant->delete_contentfilteredtopic(filteredtopic2);
    checkStatus(status, "DDS.DomainParticipant.delete_topic");
  }
  if ( topic != NULL) {
    status = participant->delete_topic(topic);
    checkStatus(status, "DDS.DomainParticipant.delete_topic");
  }
  if ( topic2 != NULL) {
    status = participant->delete_topic(topic2);
    checkStatus(status, "DDS.DomainParticipant.delete_topic");
  }
  for (int i=0; i<SAL__ACTORS_MAXCOUNT;i++) {
    if ( sal[i].topic != NULL) {
      status = participant->delete_topic(sal[i].topic);
      checkStatus(status, "DDS.DomainParticipant.delete_topic");
    }
    if ( sal[i].topic2 != NULL) {
      status = participant->delete_topic(sal[i].topic2);
      checkStatus(status, "DDS.DomainParticipant.delete_topic");
    }
    if ( sal[i].filteredtopic != NULL) {
      status = participant->delete_contentfilteredtopic(sal[i].filteredtopic);
      checkStatus(status, "DDS.DomainParticipant.delete_topic");
    }
    if ( sal[i].filteredtopic2 != NULL) {
      status = participant->delete_contentfilteredtopic(sal[i].filteredtopic2);
      checkStatus(status, "DDS.DomainParticipant.delete_topic");
    }
  }  

}


void SAL_SALData::createPublisher()
{
  status = participant->get_default_publisher_qos(pub_qos);
  checkStatus(status, "DDS::DomainParticipant::get_default_publisher_qos");
  pub_qos.partition.name.length(1);
  pub_qos.partition.name[0] = partition;

  publisher = participant->create_publisher(pub_qos, NULL, STATUS_MASK_NONE);
  checkHandle(publisher.in(), "DDS::DomainParticipant::create_publisher");
}

void SAL_SALData::createPublisher(int actorIdx)
{
  status = participant->get_default_publisher_qos(sal[actorIdx].pub_qos);
  checkStatus(status, "DDS::DomainParticipant::get_default_publisher_qos");
  sal[actorIdx].pub_qos.partition.name.length(1);
  sal[actorIdx].pub_qos.partition.name[0] = partition;

  sal[actorIdx].publisher = participant->create_publisher(sal[actorIdx].pub_qos, NULL, STATUS_MASK_NONE);
  checkHandle(sal[actorIdx].publisher.in(), "DDS::DomainParticipant::create_publisher");
}


void SAL_SALData::deletePublisher()
{
    if (publisher != NULL) {
       status = participant->delete_publisher(publisher.in());
       checkStatus(status, "DDS::DomainParticipant::delete_publisher ");
    }
    for (int i=0; i<SAL__ACTORS_MAXCOUNT;i++) {
        if ( sal[i].publisher != NULL) {
       cout << "    deletePublisher : " << i << endl;
          status = participant->delete_publisher(sal[i].publisher.in());
          checkStatus(status, "DDS::DomainParticipant::delete_publisher ");
        }
    }
}


void SAL_SALData::createWriter()
{
  writer = publisher->create_datawriter(topic.in(),
    DATAWRITER_QOS_USE_TOPIC_QOS, NULL, STATUS_MASK_NONE);
  checkHandle(writer, "DDS::Publisher::create_datawriter");
}

void SAL_SALData::createWriter2()
{
  writer2 = publisher->create_datawriter(topic2.in(),
    DATAWRITER_QOS_USE_TOPIC_QOS, NULL, STATUS_MASK_NONE);
  checkHandle(writer2, "DDS::Publisher::create_datawriter");
}


void SAL_SALData::createWriter(int actorIdx)
{
  int status;
  status = sal[actorIdx].publisher->get_default_datawriter_qos(sal[actorIdx].dw_qos);
  checkStatus(status, "DDS::DomainParticipant::get_default_publisher_qos");
  status = sal[actorIdx].publisher->copy_from_topic_qos(sal[actorIdx].dw_qos, sal[actorIdx].reliable_topic_qos);
  checkStatus(status, "DDS::Publisher::copy_from_topic_qos");
  sal[actorIdx].dw_qos.writer_data_lifecycle.autodispose_unregistered_instances = false;
  sal[actorIdx].writer = sal[actorIdx].publisher->create_datawriter(sal[actorIdx].topic.in(),
    DATAWRITER_QOS_USE_TOPIC_QOS, NULL, STATUS_MASK_NONE);
  checkHandle(sal[actorIdx].writer, "DDS::Publisher::create_datawriter");
}

void SAL_SALData::createWriter2(int actorIdx)
{
  int status;
  status = sal[actorIdx].publisher->get_default_datawriter_qos(sal[actorIdx].dw_qos);
  checkStatus(status, "DDS::DomainParticipant::get_default_publisher_qos");
  status = sal[actorIdx].publisher->copy_from_topic_qos(sal[actorIdx].dw_qos, sal[actorIdx].reliable_topic_qos2);
  checkStatus(status, "DDS::Publisher::copy_from_topic_qos");
  sal[actorIdx].dw_qos.writer_data_lifecycle.autodispose_unregistered_instances = false;
  sal[actorIdx].writer2 = sal[actorIdx].publisher->create_datawriter(sal[actorIdx].topic2.in(),
    DATAWRITER_QOS_USE_TOPIC_QOS, NULL, STATUS_MASK_NONE);
  checkHandle(sal[actorIdx].writer2, "DDS::Publisher::create_datawriter");
}



void SAL_SALData::createWriter(bool autodispose_unregistered_instances)
{
  status = publisher->get_default_datawriter_qos(dw_qos);
  checkStatus(status, "DDS::DomainParticipant::get_default_publisher_qos");
  status = publisher->copy_from_topic_qos(dw_qos, reliable_topic_qos);
  checkStatus(status, "DDS::Publisher::copy_from_topic_qos");
  // Set autodispose to false so that you can start
  // the subscriber after the publisher
  dw_qos.writer_data_lifecycle.autodispose_unregistered_instances =
    autodispose_unregistered_instances;
  writer = publisher->create_datawriter(topic.in(), dw_qos, NULL,
    STATUS_MASK_NONE);
  checkHandle(writer, "DDS::Publisher::create_datawriter");
  hasWriter = true;
}

void SAL_SALData::createWriter2(bool autodispose_unregistered_instances)
{
  status = publisher->get_default_datawriter_qos(dw_qos);
  checkStatus(status, "DDS::DomainParticipant::get_default_publisher_qos");
  status = publisher->copy_from_topic_qos(dw_qos, reliable_topic_qos2);
  checkStatus(status, "DDS::Publisher::copy_from_topic_qos");
  // Set autodispose to false so that you can start
  // the subscriber after the publisher
  dw_qos.writer_data_lifecycle.autodispose_unregistered_instances =
    autodispose_unregistered_instances;
  writer2 = publisher->create_datawriter(topic2.in(), dw_qos, NULL,
    STATUS_MASK_NONE);
  checkHandle(writer2, "DDS::Publisher::create_datawriter");
   hasWriter = true;
}


void SAL_SALData::createWriter(int actorIdx,bool autodispose_unregistered_instances)
{
  status = sal[actorIdx].publisher->get_default_datawriter_qos(sal[actorIdx].dw_qos);
  checkStatus(status, "DDS::DomainParticipant::get_default_publisher_qos");
  status = sal[actorIdx].publisher->copy_from_topic_qos(sal[actorIdx].dw_qos, sal[actorIdx].reliable_topic_qos);
  checkStatus(status, "DDS::Publisher::copy_from_topic_qos");
  // Set autodispose to false so that you can start
  // the subscriber after the publisher
  sal[actorIdx].dw_qos.writer_data_lifecycle.autodispose_unregistered_instances =
    autodispose_unregistered_instances;
  sal[actorIdx].writer = sal[actorIdx].publisher->create_datawriter(sal[actorIdx].topic.in(), sal[actorIdx].dw_qos, NULL,
    STATUS_MASK_NONE);
  checkHandle(sal[actorIdx].writer, "DDS::Publisher::create_datawriter");
  sal[actorIdx].isWriter = true;
}

void SAL_SALData::createWriter2(int actorIdx,bool autodispose_unregistered_instances)
{
  status = sal[actorIdx].publisher->get_default_datawriter_qos(sal[actorIdx].dw_qos);
  checkStatus(status, "DDS::DomainParticipant::get_default_publisher_qos");
  status = sal[actorIdx].publisher->copy_from_topic_qos(sal[actorIdx].dw_qos, sal[actorIdx].reliable_topic_qos2);
  checkStatus(status, "DDS::Publisher::copy_from_topic_qos");
  // Set autodispose to false so that you can start
  // the subscriber after the publisher
  sal[actorIdx].dw_qos.writer_data_lifecycle.autodispose_unregistered_instances =
    autodispose_unregistered_instances;
  sal[actorIdx].writer2 = sal[actorIdx].publisher->create_datawriter(sal[actorIdx].topic2.in(), sal[actorIdx].dw_qos, NULL,
    STATUS_MASK_NONE);
  checkHandle(sal[actorIdx].writer2, "DDS::Publisher::create_datawriter");
  sal[actorIdx].isWriter = true;
}

void SAL_SALData::deleteWriter()
{
  if (writer != NULL) {
    status = publisher->delete_datawriter(writer);
    checkStatus(status, "DDS::Publisher::delete_datawriter ");
  }
  if (writer2 != NULL) {
    status = publisher->delete_datawriter(writer2);
    checkStatus(status, "DDS::Publisher::delete_datawriter ");
  }
  for (int i=0; i<SAL__ACTORS_MAXCOUNT;i++) {
      if ( sal[i].writer != NULL) {
        status = sal[i].publisher->delete_datawriter(sal[i].writer);
        checkStatus(status, "DDS::Publisher::delete_datawriter ");
      }
      if ( sal[i].writer2 != NULL) {
        status = sal[i].publisher->delete_datawriter(sal[i].writer2);
        checkStatus(status, "DDS::Publisher::delete_datawriter ");
      }
  }
}

void SAL_SALData::createSubscriber()
{
  int status = participant->get_default_subscriber_qos(sub_qos);
  checkStatus(status, "DDS::DomainParticipant::get_default_subscriber_qos");
  sub_qos.partition.name.length(1);
  sub_qos.partition.name[0] = partition;
  subscriber = participant->create_subscriber(sub_qos, NULL, STATUS_MASK_NONE);
  checkHandle(subscriber.in(), "DDS::DomainParticipant::create_subscriber");
}


void SAL_SALData::createSubscriber(int actorIdx)
{
  int status = participant->get_default_subscriber_qos(sal[actorIdx].sub_qos);
  checkStatus(status, "DDS::DomainParticipant::get_default_subscriber_qos");
  sal[actorIdx].sub_qos.partition.name.length(1);
  sal[actorIdx].sub_qos.partition.name[0] = partition;
  sal[actorIdx].subscriber = participant->create_subscriber(sal[actorIdx].sub_qos, NULL, STATUS_MASK_NONE);
  checkHandle(sal[actorIdx].subscriber.in(), "DDS::DomainParticipant::create_subscriber");
}


void SAL_SALData::deleteSubscriber()
{
  if (subscriber != NULL) {
     status = participant->delete_subscriber(subscriber);
     checkStatus(status, "DDS::DomainParticipant::delete_subscriber ");
  }
  for (int i=0; i<SAL__ACTORS_MAXCOUNT;i++) {
    if (sal[i].subscriber != NULL) {
      status = participant->delete_subscriber(sal[i].subscriber);
      checkStatus(status, "DDS::DomainParticipant::delete_subscriber ");
    }
  }
}

void SAL_SALData::createReader(bool filtered)
{
  if (filtered) {
    reader = subscriber->create_datareader(filteredtopic.in(),
    DATAREADER_QOS_USE_TOPIC_QOS, NULL, STATUS_MASK_NONE);
  } else {
    reader = subscriber->create_datareader(topic.in(),
    DATAREADER_QOS_USE_TOPIC_QOS, NULL, STATUS_MASK_NONE);
  }
  checkHandle(reader, "DDS::Subscriber::create_datareader ()");
  hasReader = true;
}

void SAL_SALData::createReader2(bool filtered)
{
  if (filtered) {
    reader2 = subscriber->create_datareader(filteredtopic2.in(),
    DATAREADER_QOS_USE_TOPIC_QOS, NULL, STATUS_MASK_NONE);
  } else {
    reader2 = subscriber->create_datareader(topic2.in(),
    DATAREADER_QOS_USE_TOPIC_QOS, NULL, STATUS_MASK_NONE);
  }
  checkHandle(reader2, "DDS::Subscriber::create_datareader ()");
  hasReader = true;
}


void SAL_SALData::createReader(int actorIdx,bool filtered)
{
  if (filtered) {
    sal[actorIdx].reader = sal[actorIdx].subscriber->create_datareader(sal[actorIdx].filteredtopic.in(),
    DATAREADER_QOS_USE_TOPIC_QOS, NULL, STATUS_MASK_NONE);
  } else {
    sal[actorIdx].reader = sal[actorIdx].subscriber->create_datareader(sal[actorIdx].topic.in(),
    DATAREADER_QOS_USE_TOPIC_QOS, NULL, STATUS_MASK_NONE);
  }
  checkHandle(sal[actorIdx].reader, "DDS::Subscriber::create_datareader ()");
  sal[actorIdx].isReader = true;
  DDS::Duration_t a_timeout;
  a_timeout.sec = historySync;
  a_timeout.nanosec = 10000000;
  sal[actorIdx].sampleAge = 1.0e20;
  status = sal[actorIdx].reader->wait_for_historical_data(a_timeout);
}

void SAL_SALData::createReader2(int actorIdx,bool filtered)
{
  status = sal[actorIdx].subscriber->get_default_datareader_qos(sal[actorIdx].dr_qos);
  checkStatus(status, "DDS::DomainParticipant::get_default_datareader_qos");
  status = sal[actorIdx].subscriber->copy_from_topic_qos(sal[actorIdx].dr_qos, sal[actorIdx].reliable_topic_qos2);
  checkStatus(status, "DDS::Subscriber::copy_from_topic_qos");
  if (filtered) {
    sal[actorIdx].reader2 = sal[actorIdx].subscriber->create_datareader(sal[actorIdx].filteredtopic2.in(),
    sal[actorIdx].dr_qos, NULL, STATUS_MASK_NONE);
  } else {
    sal[actorIdx].reader2 = sal[actorIdx].subscriber->create_datareader(sal[actorIdx].topic2.in(),
    sal[actorIdx].dr_qos, NULL, STATUS_MASK_NONE);
  }
  checkHandle(sal[actorIdx].reader2, "DDS::Subscriber::create_datareader ()");
  sal[actorIdx].isReader = true;
  DDS::Duration_t a_timeout;
  a_timeout.sec = historySync;
  a_timeout.nanosec = 10000000;
  sal[actorIdx].sampleAge = 1.0e20;
  status = sal[actorIdx].reader2->wait_for_historical_data(a_timeout);
}


void SAL_SALData::deleteReader()
{
  if (reader != NULL) {
    status = subscriber->delete_datareader(reader);
    checkStatus(status, "DDS::Subscriber::delete_datareader ");
  }
  if (reader2 != NULL) {
    status = subscriber->delete_datareader(reader2);
    checkStatus(status, "DDS::Subscriber::delete_datareader ");
  }
  for (int i=0; i<SAL__ACTORS_MAXCOUNT;i++) {
    if (sal[i].reader != NULL) {
      status = sal[i].subscriber->delete_datareader(sal[i].reader);
      checkStatus(status, "DDS::Subscriber::delete_datareader ");
    }
    if (sal[i].reader2 != NULL) {
      status = sal[i].subscriber->delete_datareader(sal[i].reader2);
      checkStatus(status, "DDS::Subscriber::delete_datareader ");
    }
  }
}



DataReader_ptr SAL_SALData::getReader()
{
  return DataReader::_duplicate(reader.in());
}

DataReader_ptr SAL_SALData::getReader2()
{
  return DataReader::_duplicate(reader2.in());
}

DataReader_ptr SAL_SALData::getReader(int actorIdx)
{
  return DataReader::_duplicate(sal[actorIdx].reader.in());
}

DataReader_ptr SAL_SALData::getReader2(int actorIdx)
{
  return DataReader::_duplicate(sal[actorIdx].reader2.in());
}



DataWriter_ptr SAL_SALData::getWriter()
{
  return DataWriter::_duplicate(writer.in());
}

DataWriter_ptr SAL_SALData::getWriter2()
{
  return DataWriter::_duplicate(writer2.in());
}


DataWriter_ptr SAL_SALData::getWriter(int actorIdx)
{
  return DataWriter::_duplicate(sal[actorIdx].writer.in());
}

DataWriter_ptr SAL_SALData::getWriter2(int actorIdx)
{
  return DataWriter::_duplicate(sal[actorIdx].writer2.in());
}



Publisher_ptr SAL_SALData::getPublisher()
{
  return Publisher::_duplicate(publisher.in());
}

Subscriber_ptr SAL_SALData::getSubscriber()
{
  return Subscriber::_duplicate(subscriber.in());
}


Publisher_ptr SAL_SALData::getPublisher(int actorIdx)
{
  return Publisher::_duplicate(sal[actorIdx].publisher.in());
}

Subscriber_ptr SAL_SALData::getSubscriber(int actorIdx)
{
  return Subscriber::_duplicate(sal[actorIdx].subscriber.in());
}


Topic_ptr SAL_SALData::getTopic()
{
  return Topic::_duplicate(topic.in());
}

Topic_ptr SAL_SALData::getTopic(int actorIdx)
{
  return Topic::_duplicate(sal[actorIdx].topic.in());
}

Topic_ptr SAL_SALData::getTopic2(int actorIdx)
{
  return Topic::_duplicate(sal[actorIdx].topic2.in());
}



DomainParticipant_ptr SAL_SALData::getParticipant()
{
  return DomainParticipant::_duplicate(participant.in());
}

SAL_SALData::~SAL_SALData(){
    salShutdown();
}



